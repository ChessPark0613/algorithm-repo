## 사과 방문 최단 경로 (맨해튼, 백트래킹)

시작점 `(0,0)`에서 `N`개의 사과 좌표를 **모두 방문**한 뒤 다시 시작점으로 돌아오는 경로 중, **맨해튼 거리 합이 최소**가 되는 값을 구합니다.
모든 순서를 시도하는 **완전탐색 + 백트래킹**으로 해결합니다.

---

### 핵심 아이디어

* 거리: `manhattan(a, b) = |ax - bx| + |ay - by|`
* 순열 탐색: `used[]`로 방문 여부를 관리하고, `dfs(depth, cur_pos, cost)`로 현재 위치와 누적 비용을 넘기며 깊게 탐색
* 종료 조건: `depth == N`이면 시작점 `(0,0)`으로 복귀 거리를 더해 `best` 갱신
* 전역 최솟값: `best`를 전역으로 두고, 테스트케이스마다 초기화

> 구조 요약
>
> * `manhattan`: 두 점의 맨해튼 거리
> * `dfs`: 백트래킹으로 순서 탐색 및 최소 비용 갱신
> * `solve`: 한 테스트케이스 처리(전역 `best` 사용)

---

## 복잡도

* 시간 복잡도: **O(N!)** (모든 방문 순서를 탐색)

  * 각 단계에서 `O(1)` 비용 갱신이므로 지배항은 순열 수
* 공간 복잡도: **O(N)** (재귀 스택 + 방문 배열)

> ⚠️ `N`이 커지면 계산량이 급격히 증가합니다. 실전에서는 `N≤10` 정도에서만 실용적입니다.
